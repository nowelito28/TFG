


noel@localhost:/usr/src/linux-source-6.8.0/linux-source-6.8.0/fs$ grep -nR "_APPEND"

overlayfs/inode.c:708:		fa->fsx_xflags |= FS_XFLAG_APPEND;
open.c:95:	if (IS_APPEND(inode))
open.c:188:	/* Check IS_APPEND on real upper inode */
open.c:189:	if (IS_APPEND(file_inode(f.file)))
open.c:287:	if ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))
open.c:1290:	if (flags & O_APPEND)

open.c:1291:		acc_mode |= MAY_APPEND;

btrfs/fs.h:776:	/* Constraints for ZONE_APPEND commands: */

noel@localhost:/usr/src/linux-source-6.8.0/linux-source-6.8.0/fs$ less +1291 -N open.c


1185 #define WILL_CREATE(flags)      (flags & (O_CREAT | __O
   1185 _TMPFILE))
   1186 #define O_PATH_FLAGS            (O_DIRECTORY | O_NOFOLL
   1186 OW | O_PATH | O_CLOEXEC)
   1187 
   1188 inline struct open_how build_open_how(int flags, umode_
   1188 t mode)
   1189 {
   1190         struct open_how how = {
   1191                 .flags = flags & VALID_OPEN_FLAGS,
   1192                 .mode = mode & S_IALLUGO,
   1193         };
   1194 
   1195         /* O_PATH beats everything else. */
   1196         if (how.flags & O_PATH)
   1197                 how.flags &= O_PATH_FLAGS;
   1198         /* Modes should only be set for create-like fla
   1198 gs. */
   1199         if (!WILL_CREATE(how.flags))
   1200                 how.mode = 0;
   1201         return how;
   1202 }
   1203 
   1204 inline int build_open_flags(const struct open_how *how,   1204  struct open_flags *op)
   1205 {
   1206         u64 flags = how->flags;
   1207         u64 strip = __FMODE_NONOTIFY | O_CLOEXEC;
   1208         int lookup_flags = 0;
   1209         int acc_mode = ACC_MODE(flags);
   1210 
   1211         BUILD_BUG_ON_MSG(upper_32_bits(VALID_OPEN_FLAGS   1211 ),
   1212                          "struct open_flags doesn't yet   1212  handle flags > 32 bits");
   1213 
   1214         /*
   1215          * Strip flags that either shouldn't be set by    1215 userspace like
   1216          * FMODE_NONOTIFY or that aren't relevant in de   1216 termining struct
   1217          * open_flags like O_CLOEXEC.
   1218          */
   1219         flags &= ~strip;
   1220 
   1221         /*
   1222          * Older syscalls implicitly clear all of the i   1222 nvalid flags or argument
   1223          * values before calling build_open_flags(), bu   1223 t openat2(2) checks all
   1224          * of its arguments.
   1225          */
   1226         if (flags & ~VALID_OPEN_FLAGS)
   1227                 return -EINVAL;
   1228         if (how->resolve & ~VALID_RESOLVE_FLAGS)
   1229                 return -EINVAL;
   1230 
   1231         /* Scoping flags are mutually exclusive. */
   1232         if ((how->resolve & RESOLVE_BENEATH) && (how->r   1232 esolve & RESOLVE_IN_ROOT))
   1233                 return -EINVAL;
   1234 
   1235         /* Deal with the mode. */
   1236         if (WILL_CREATE(flags)) {
   1237                 if (how->mode & ~S_IALLUGO)
   1238                         return -EINVAL;
   1239                 op->mode = how->mode | S_IFREG;
   1240         } else {
    1241                 if (how->mode != 0)
    1242                         return -EINVAL;
    1243                 op->mode = 0;
    1244         }
    1245 
    1246         /*
    1247          * Block bugs where O_DIRECTORY | O_CREAT creat   1247 ed regular files.
    1248          * Note, that blocking O_DIRECTORY | O_CREAT he   1248 re also protects
    1249          * O_TMPFILE below which requires O_DIRECTORY b   1249 eing raised.
    1250          */
    1251         if ((flags & (O_DIRECTORY | O_CREAT)) == (O_DIR   1251 ECTORY | O_CREAT))
    1252                 return -EINVAL;
    1253 
    1254         /* Now handle the creative implementation of O_   1254 TMPFILE. */
    1255         if (flags & __O_TMPFILE) {
    1256                 /*
    1257                  * In order to ensure programs get expl   1257 icit errors when trying
    1258                  * to use O_TMPFILE on old kernels we enforce that O_DIRECTORY
   1259                  * is raised alongside __O_TMPFILE.
   1260                  */
   1261                 if (!(flags & O_DIRECTORY))
   1262                         return -EINVAL;
   1263                 if (!(acc_mode & MAY_WRITE))
   1264                         return -EINVAL;
   1265         }
   1266         if (flags & O_PATH) {
   1267                 /* O_PATH only permits certain other fl   1267 ags to be set. */
   1268                 if (flags & ~O_PATH_FLAGS)
   1269                         return -EINVAL;
   1270                 acc_mode = 0;
   1271         }
   1272 
   1273         /*
   1274          * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only
   1275          * check for O_DSYNC if the need any syncing at
   1275  all we enforce it's
   1276          * always set instead of having to deal with po
   1276 ssibly weird behaviour
   1277          * for malicious applications setting only __O_   1277 SYNC.
   1278          */
   1279         if (flags & __O_SYNC)
   1280                 flags |= O_DSYNC;
   1281 
   1282         op->open_flag = flags;
   1283 
   1284         /* O_TRUNC implies we need access checks for wr   1284 ite permissions */
   1285         if (flags & O_TRUNC)
   1286                 acc_mode |= MAY_WRITE;
   1287 
   1288         /* Allow the LSM permission hook to distinguish   1288  append
   1289            access from general write access. */
   1290         if (flags & O_APPEND)
   1291                 acc_mode |= MAY_APPEND;
   1292 
   1293         op->acc_mode = acc_mode;
   1294 
   1295         op->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;
   1296 
   1297         if (flags & O_CREAT) {
   1298                 op->intent |= LOOKUP_CREATE;
   1299                 if (flags & O_EXCL) {
   1300                         op->intent |= LOOKUP_EXCL;
   1301                         flags |= O_NOFOLLOW;
   1302                 }
   1303         }
   1304 
   1305         if (flags & O_DIRECTORY)
   1306                 lookup_flags |= LOOKUP_DIRECTORY;
   1307         if (!(flags & O_NOFOLLOW))
   1308                 lookup_flags |= LOOKUP_FOLLOW;
   1309 
   1310         if (how->resolve & RESOLVE_NO_XDEV)
   1311                 lookup_flags |= LOOKUP_NO_XDEV;
   1312         if (how->resolve & RESOLVE_NO_MAGICLINKS)
   1313                 lookup_flags |= LOOKUP_NO_MAGICLINKS;
   1314         if (how->resolve & RESOLVE_NO_SYMLINKS)
   1315                 lookup_flags |= LOOKUP_NO_SYMLINKS;
   1316         if (how->resolve & RESOLVE_BENEATH)
   1317                 lookup_flags |= LOOKUP_BENEATH;
   1318         if (how->resolve & RESOLVE_IN_ROOT)
   1319                 lookup_flags |= LOOKUP_IN_ROOT;
   1320         if (how->resolve & RESOLVE_CACHED) {
   1321                 /* Don't bother even trying for create/   1321 truncate/tmpfile open */
   1322                 if (flags & (O_TRUNC | O_CREAT | __O_TM   1322 PFILE))
   1323                         return -EAGAIN;
   1324                 lookup_flags |= LOOKUP_CACHED;
   1325         }
   1326 
   1327         op->lookup_flags = lookup_flags;
   1328         return 0;
   1329 }
