
localhost:LKM:# less +2766 /usr/src/linux-source-6.8.0/linux-source-6.8.0/include/linux/fs.h

/usr/src/linux-source-6.8.0/linux-source-6.8.0/include/linux/fs.h:2766:static inline int file_permission(struct file *file, int mask)




extern void emergency_sync(void);
extern void emergency_remount(void);

#ifdef CONFIG_BLOCK
extern int bmap(struct inode *inode, sector_t *block);
#else
static inline int bmap(struct inode *inode,  sector_t *block)
{
        return -EINVAL;
}
#endif

int notify_change(struct mnt_idmap *, struct dentry *,
                  struct iattr *, struct inode **);
int inode_permission(struct mnt_idmap *, struct inode *, int);
int generic_permission(struct mnt_idmap *, struct inode *, int);


static inline int file_permission(struct file *file, int mask)
{
        return inode_permission(file_mnt_idmap(file),
                                file_inode(file), mask);
}


static inline int path_permission(const struct path *path, int mask)
{
        return inode_permission(mnt_idmap(path->mnt),
                                d_inode(path->dentry), mask);
}
int __check_sticky(struct mnt_idmap *idmap, struct inode *dir,
                   struct inode *inode);

static inline bool execute_ok(struct inode *inode)
{
        return (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode);
}

static inline bool inode_wrong_type(const struct inode *inode, umode_t mode)
{
        return (inode->i_mode ^ mode) & S_IFMT;
}


localhost:LKM:# grep -r "file_permission" /usr/src/linux-source-6.8.0/linux-source-6.8.0/fs

/usr/src/linux-source-6.8.0/linux-source-6.8.0/fs/namei.c:504:int inode_permission(struct mnt_idmap *idmap,

/**
 * inode_permission - Check for access rights to a given inode
 * @idmap:      idmap of the mount the inode was found from
 * @inode:      Inode to check permission on
 * @mask:       Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)
 *
 * Check for read/write/execute permissions on an inode.  We use fs[ug]id for
 * this, letting us set arbitrary permissions for filesystem access without
 * changing the "normal" UIDs which are used for other things.
 *
 * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.
 */
int inode_permission(struct mnt_idmap *idmap,
        struct inode *inode, int mask)
{
        int retval;
        if (retval)
        return retval;

        if (unlikely(mask & MAY_WRITE)) {
        /*
        * Nobody gets write access to an immutable file.
        */
        if (IS_IMMUTABLE(inode))
                return -EPERM;

        /*
        * Updating mtime will likely cause i_uid and i_gid to be
        * written back improperly if their true value is unknown
        * to the vfs.
        */
        if (HAS_UNMAPPED_ID(idmap, inode))
                return -EACCES;
        }

        retval = do_inode_permission(idmap, inode, mask);
        if (retval)
                return retval;

        retval = devcgroup_inode_permission(inode, mask);
        if (retval)
                return retval;

        retval = devcgroup_inode_permission(inode, mask);
        if (retval)
                return retval;

        return security_inode_permission(inode, mask);
}
EXPORT_SYMBOL(inode_permission);
