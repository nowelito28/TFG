
localhost:LKM:# grep -rn "security_file_permission" /usr/src/linux-source-6.8.0/linux-source-6.8.0/security
/usr/src/linux-source-6.8.0/linux-source-6.8.0/security/security.c:2756: * security_file_permission() - Check file permissions
/usr/src/linux-source-6.8.0/linux-source-6.8.0/security/security.c:2774:int security_file_permission(struct file *file, int mask)
localhost:LKM:# less +2774 /usr/src/linux-source-6.8.0/linux-source-6.8.0/security/security.c


/**
 * security_file_permission() - Check file permissions
 * @file: file
 * @mask: requested permissions
 *
 * Check file permissions before accessing an open file.  This hook is called
 * by various operations that read or write files.  A security module can use
 * this hook to perform additional checking on these operations, e.g. to
 * revalidate permissions on use to support privilege bracketing or policy
 * changes.  Notice that this hook is used when the actual read/write
 * operations are performed, whereas the inode_security_ops hook is called when
 * a file is opened (as well as many other operations).  Although this hook can
 * be used to revalidate permissions for various system call operations that
 * read or write files, it does not address the revalidation of permissions for
 * memory-mapped files.  Security modules must handle this separately if they
 * need such revalidation.
 *
 * Return: Returns 0 if permission is granted.
 */
int security_file_permission(struct file *file, int mask)
{
        return call_int_hook(file_permission, 0, file, mask);
}
