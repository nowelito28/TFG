localhost:fs:# pwd
/usr/src/linux-source-6.8.0/linux-source-6.8.0/fs

localhost:fs:# grep -Rn 'kernel_write\s*('
btrfs/send.c:648:		ret = kernel_write(filp, buf + pos, len - pos, off);
btrfs/send.c:7289:	 * Down this call chain we write to the pipe through kernel_write().

read_write.c:535:ssize_t __kernel_write(struct file *file, const void *buf, size_t count, loff_t *pos)
read_write.c:554:ssize_t kernel_write(struct file *file, const void *buf, size_t count,

read_write.c:564:	ret =  __kernel_write(file, buf, count, pos);
proc/proc_sysctl.c:1666:	wret = kernel_write(file, val, len, &pos);
ecryptfs/read_write.c:36:	rc = kernel_write(lower_file, data, size, &offset);
coredump.c:813:	n = __kernel_write(file, addr, nr, &pos);
ext4/verity.c:65: * kernel_write() can't be used because the file descriptor is readonly.
smb/server/vfs.c:530:	err = kernel_write(filp, buf, count, pos);
f2fs/verity.c:69: * kernel_write() can't be used because the file descriptor is readonly.
pstore/blk.c:199:	return kernel_write(psblk_file, buf, bytes, &pos);
autofs/waitq.c:57:		wr = __kernel_write(file, data, bytes, NULL);

localhost:fs:# less +535 -N read_write.c
504 /* caller is responsible for file_start_write/file_end_write */
505 ssize_t __kernel_write_iter(struct file *file, struct iov_iter *from, lo
505 ff_t *pos)
506 {
507         struct kiocb kiocb;
508         ssize_t ret;
509 
510         if (WARN_ON_ONCE(!(file->f_mode & FMODE_WRITE)))
511                 return -EBADF;
512         if (!(file->f_mode & FMODE_CAN_WRITE))
513                 return -EINVAL;
514         /*
515          * Also fail if ->write_iter and ->write are both wired up as th
515 at
516          * implies very convoluted semantics.
517          */
518         if (unlikely(!file->f_op->write_iter || file->f_op->write))
519                 return warn_unsupported(file, "write");
520 
521         init_sync_kiocb(&kiocb, file);
522         kiocb.ki_pos = pos ? *pos : 0;
523         ret = file->f_op->write_iter(&kiocb, from);
524         if (ret > 0) {
525                 if (pos)
526                         *pos = kiocb.ki_pos;
527                 fsnotify_modify(file);
528                 add_wchar(current, ret);
529         }
530         inc_syscw(current);
531         return ret;
532 }
533 
534 /* caller is responsible for file_start_write/file_end_write */
535 ssize_t __kernel_write(struct file *file, const void *buf, size_t count,    535  loff_t *pos)
536 {
537         struct kvec iov = {
538                 .iov_base       = (void *)buf,
539                 .iov_len        = min_t(size_t, count, MAX_RW_COUNT),
540         };
541         struct iov_iter iter;
542         iov_iter_kvec(&iter, ITER_SOURCE, &iov, 1, iov.iov_len);
543         return __kernel_write_iter(file, &iter, pos);
544 }
545 /*
546  * This "EXPORT_SYMBOL_GPL()" is more of a "EXPORT_SYMBOL_DONTUSE()",
547  * but autofs is one of the few internal kernel users that actually
548  * wants this _and_ can be built as a module. So we need to export
549  * this symbol for autofs, even though it really isn't appropriate
550  * for any other kernel modules.
551  */
552 EXPORT_SYMBOL_GPL(__kernel_write);
553 
554 ssize_t kernel_write(struct file *file, const void *buf, size_t count,
555                             loff_t *pos)
556 {
557         ssize_t ret;
558 
559         ret = rw_verify_area(WRITE, file, pos, count);
560         if (ret)
561                 return ret;
562 
563         file_start_write(file);
564         ret =  __kernel_write(file, buf, count, pos);
565         file_end_write(file);
566         return ret;
567 }
568 EXPORT_SYMBOL(kernel_write);
